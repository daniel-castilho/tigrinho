package com.tigrinho.slot.service;

import com.tigrinho.slot.exception.ResourceNotFoundException;
import com.tigrinho.slot.model.entity.Player;
import com.tigrinho.slot.repository.PlayerRepository;
import com.tigrinho.slot.service.strategy.WinStrategy;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

import java.math.BigDecimal;
import java.math.BigInteger;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;

/**
 * Service responsible for generating game spin results using a Provably Fair mechanism.
 * It orchestrates the use of player seeds, cryptographic hashing, and win strategies
 * to produce deterministic and verifiable game outcomes.
 */
@Slf4j
@Service
@RequiredArgsConstructor
public class RNGService {

    private static final List<String> SYMBOLS = List.of("CEREJA", "LARANJA", "SETE", "BAR");

    private final List<WinStrategy> winStrategies;
    private final CryptoService cryptoService;
    private final PlayerRepository playerRepository;

    /**
     * Generates a deterministic game spin result using the Provably Fair system.
     * This method fetches player seeds, computes an HMAC hash, converts it to symbols,
     * increments the player's nonce, and calculates the win amount based on defined strategies.
     *
     * @param playerId The ID of the player for whom to generate the spin result.
     * @param betAmount The amount of money bet on this spin.
     * @return A {@link SpinResult} object containing the generated symbols and the win amount.
     * @throws ResourceNotFoundException if the player is not found.
     */
    public SpinResult generateSpinResult(final String playerId, final BigDecimal betAmount) {

        // 1. Fetch the player to get their seeds
        final Player player = playerRepository.findById(playerId)
                .orElseThrow(() -> new ResourceNotFoundException("Player", "id", playerId));

        // 2. Prepare data for HMAC calculation
        final String serverSeed = player.getServerSeed();
        final String clientSeed = player.getClientSeed();
        final Long nonce = player.getNonce();
        final String data = clientSeed + ":" + nonce; // Combines clientSeed and nonce

        // 3. Calculate the HMAC hash (This is the raw "result")
        // This hash is 100% deterministic based on the input
        final String hmacHash = cryptoService.hmac(serverSeed, data);

        // 4. Convert the hash into game symbols
        final List<String> symbols = convertHashToSymbols(hmacHash);

        // 5. Increment the nonce and save the player
        // This ensures the next spin (nonce + 1) will have a different result
        player.setNonce(nonce + 1);
        playerRepository.save(player);

        // 6. Calculate the win amount using the Strategy Pattern
        final BigDecimal winAmount = calculateWinAmount(symbols, betAmount);

        return new SpinResult(symbols, winAmount);
    }

    /**
     * Converts an HMAC hash into a list of 3 game symbols in a deterministic way.
     * The hash is split into segments, and each segment is mapped to a symbol
     * based on its numerical value modulo the number of available symbols.
     *
     * @param hmacHash The HMAC hash string to convert.
     * @return A {@link List} of 3 game symbols.
     */
    private List<String> convertHashToSymbols(final String hmacHash) {
        final List<String> resultSymbols = new ArrayList<>();
        final int symbolsToGenerate = 3;
        final int symbolsCount = SYMBOLS.size();

        // Use substrings of the hash to generate each symbol
        for (int i = 0; i < symbolsToGenerate; i++) {
            // Take 8 characters from the hash for each symbol (ensures a large number)
            final String hashSegment = hmacHash.substring(i * 8, (i + 1) * 8);

            // Convert the hexadecimal substring to a number (BigInteger)
            final BigInteger num = new BigInteger(hashSegment, 16);

            // Use modulo to get a valid index for the symbol list
            final int symbolIndex = num.mod(BigInteger.valueOf(symbolsCount)).intValue();

            resultSymbols.add(SYMBOLS.get(symbolIndex));
        }

        log.debug("Hash {} generated symbols: {}", hmacHash, resultSymbols);
        return resultSymbols;
    }

    /**
     * Calculates the win amount based on the generated symbols and the bet amount,
     * by iterating through a list of predefined {@link WinStrategy} implementations.
     * The first matching strategy determines the win.
     *
     * @param symbols The list of symbols generated by the spin.
     * @param betAmount The amount of money bet on the spin.
     * @return The calculated win amount, or {@link BigDecimal#ZERO} if no strategy matches.
     */
    private BigDecimal calculateWinAmount(final List<String> symbols, final BigDecimal betAmount) {
        // Find the first strategy that matches the symbol combination
        final Optional<WinStrategy> matchingStrategy = winStrategies.stream()
                .filter(strategy -> strategy.matches(symbols))
                .findFirst();

        // If a strategy is found, calculate the win amount. Otherwise, the win amount is ZERO.
        return matchingStrategy
                .map(strategy -> strategy.calculateWin(betAmount))
                .orElse(BigDecimal.ZERO);
    }

    /**
     * Record to encapsulate the result of an RNG spin,
     * including the generated symbols and the calculated win amount.
     * This is an internal data transfer object, not an API DTO.
     *
     * @param symbols The list of symbols generated by the spin.
     * @param winAmount The amount won in this spin.
     */
    public record SpinResult(List<String> symbols, BigDecimal winAmount) {
    }
}
